# CSS3

## 介绍

## 选择器

##### 什么是选择器

每一条css样式声明（定义）由两部分组成，形式如下：

```
选择器{
    样式;
}
```

在{}之前的部分就是“选择器”，“选择器”指明了{}中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素。

##### 标签选择器

##### 类选择器

##### ID选择器

##### 子选择器 >

子选择器，即大于符号(>),用于选择指定标签元素的**第一代子元素。**如右侧代码编辑器中的代码：

```
.food>li{border:1px solid red;}
```

这行代码会使class名为food下的子元素li（水果、蔬菜）加入红色实线边框。

##### 后代选择器

包含选择器，即加入空格,用于选择指定标签元素下的**后辈元素。**如右侧代码编辑器中的代码：

```
.first  span{color:red;}
```

这行代码会使第一段文字内容中的“胆小如鼠”字体颜色变为红色。

请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的直接后代，或者你可以理解为作用于子元素的第一代后代。而后代选择器是作用于所有子后代元素。后代选择器通过空格来进行选择，而子选择器是通过“>”进行选择。

总结：**>**作用于元素的第一代后代，**空格**作用于元素的所有后代。

##### 通用选择器 *

##### 伪类选择器

关于伪类选择符，到目前为止，可以兼容所有浏览器的“伪类选择符”就是 a 标签上使用 :hover 了（其实伪类选择符还有很多，尤其是 css3  中，但是因为不能兼容所有浏览器，本教程只是讲了这一种最常用的）。其实 :hover 可以放在任意的标签上，比如说  p:hover，但是它们的兼容性也是很不好的，所以现在比较常用的还是 a:hover 的组合。

##### 分组选择器

当你想为html中多个标签元素设置同一个样式时，可以使用分组选择符（，），如下代码为右侧代码编辑器中的h1、span标签同时设置字体颜色为红色：

```
h1,span{color:red;}
```

它相当于下面两行代码：

```
h1{color:red;}
span{color:red;}
```

## 继承、优先级和重要性

##### 继承

CSS的**某些样式**是具有继承性的，那么什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。比如下面代码：如某种颜色应用于p标签，这个颜色设置不仅应用p标签，还应用于p标签中的所有子元素文本，这里子元素为span标签。

```
p{color:red;}

<p>三年级时，我还是一个<span>胆小如鼠</span>的小女孩。</p>
```

可见右侧结果窗口中p中的文本与span中的文本都设置为了红色。但注意有一些css样式是不具有继承性的。如border:1px solid red;

```
p{border:1px solid red;}

<p>三年级时，我还是一个<span>胆小如鼠</span>的小女孩。</p>
```

在上面例子中它代码的作用只是给p标签设置了边框为1像素、红色、实心边框线，而对于子元素span是没用起到作用的。

<hr/>

##### 选择器的优先级

1、如果一个元素使用了多个选择器,则会按照选择器的优先级来给定样式。

2、选择器的优先级依次是: 内联样式 > id选择器 > 类选择器 > 标签选择器 > 通配符选择器

<hr/>

##### 权值计算

有的时候我们**为同一个元素设置了不同的CSS样式**代码，那么元素会启用哪一个CSS样式呢？下面我们一起来看一下代码：

```
p{color:red;}
.first{color:green;}
<p class="first">三年级时，我还是一个<span>胆小如鼠</span>的小女孩。</p>
```

p和.first都匹配到了p这个标签上，那么会显示哪种颜色呢？green是正确的颜色，那么为什么呢？是因为浏览器是根据权值来判断使用哪种css样式的，权值高的就使用哪种css样式。

下面是权值的规则：

**标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。**例如下面的代码：

```
p{color:red;} /*权值为1*/
p span{color:green;} /*权值为1+1=2*/
.warning{color:white;} /*权值为10*/
p span.warning{color:purple;} /*权值为1+1+10=12*/
#footer .note p{color:yellow;} /*权值为100+10+1=111*/
```

**注意：还有一个权值比较特殊--继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。**

<hr/>

##### 选择器最高层级 !inportant

我们在做网页代码的时，有些特殊的情况需要为某些样式设置具有最高权值，怎么办？这时候我们可以使用**!important**来解决。

如下代码：

```
p{color:red!important;}
p{color:green;}
<p class="first">三年级时，我还是一个<span>胆小如鼠</span>的小女孩。</p>
```

这时 p 段落中的文本会显示的red红色。

**注意：!important要写在分号的前面**

这里注意当网页制作者不设置css样式时，浏览器会按照自己的一套样式来显示网页。并且用户也可以在浏览器中设置自己习惯的样式，比如有的用户习惯把字号设置为大一些，使其查看网页的文本更加清楚。这时注意样式优先级为：**浏览器默认的样式 < 网页制作者样式 < 用户自己设置的样式**，但记住!important优先级样式是个例外，权值高于用户自己设置的样式。

##　字体样式

## 文本样式

## box属性

#### box-shadow





## 盒模型

块级标签具备盒模型的特征。

#### 元素分类

元素大体被分为三种不同的类型：**块状元素**、**内联元素(又叫行内元素)**和**内联块状元素**。

* **常用的块状元素有：**

``<div>、<p>、<h1>...<h6>、<ol>、<ul>、<dl>、<table>、<address>、<blockquote>  、<form>``

设置`display:block`就是将元素显示为块级元素。如下代码``a{display:block;}``就是将**内联元素a**转换为**块状元素**，从而使a元素具有**块状元素**特点。

<hr/>

* **常用的内联元素有：**

``<a>、<span>、<br>、<i>、<em>、<strong>、<label>、<q>、<var>、<cite>、<code>``

<hr/>

* **常用的内联块状元素有：**

``<img>、<input>``

代码`display:inline-block`就是将元素设置为内联块状元素

<hr/>

* **none**设置此元素不会被显示，当想要元素隐藏的时候可以使用此值。

#### 盒模型

* 块级元素具有盒模型的特征(height\weight\padding\margin\border)

* 当您指定一个 CSS 元素的宽度和高度属性时，你只是设置内容区域的宽度和高度。要知道，完整大小的元素，你还必须添加内边距，边框和边距。

* 总高度/宽度 = margin + border + padding + height/width

  ![img](https://img-blog.csdn.net/20180619173347603?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2NzgwMzE3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

  **即width=content**

  ​      ①**width**和**height**设置**内容框（content box）**的宽度和高度。内容框是框内容显示的区域--包括框内的文本内容，以及表示镶嵌子元素的其他框；

  ​      ②**padding**表示一个CSS框**内边距**--这一层位于内容框的外边缘与边界的内边缘之间；

  ​      ③**border**即CSS框的**边界**是一个分割层，位于内边距的外边缘以及外边距的内边缘之间；

  ​      ④**margin**即**外边距**代表CSS框周围的外部区域。

  

#### box-sizing: border-box

​      **运用`box-sizing: border-box`属性下，框模型的变化**

​      ![img](https://img-blog.csdn.net/20180619174330697?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2NzgwMzE3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

即**width=content+padding+border**(此时，当div的宽度为50%时，而border和padding为px时，那么content会随着实际的宽度进行自动缩放；)



## 布局模型

清楚了CSS3 盒模型的基本概念、 盒模型类型， 我们就可以深入探讨网页布局的基本模型了。布局模型与盒模型一样都是 CSS3 最基本、  最核心的概念。 但布局模型是建立在盒模型基础之上，又不同于我们常说的 CSS3 布局样式或 CSS3 布局模板。如果说布局模型是本，那么  CSS3 布局模板就是末了，是外在的表现形式。 CSS3包含3种基本的布局模型，用英文概括为：Flow、Layer 和 Float。
在网页中，元素有三种布局模型：
 1、流动模型（Flow）
 2、浮动模型 (Float)
 3、层模型（Layer）

#### 流动模型

**流动模型**，流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。

流动布局模型具有2个比较典型的特征：

第一点，**块状元素**都会在所处的包含元素内**自上而下**按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为**100%**。实际上，块状元素都会以行的形式占据位置。如右侧代码编辑器中三个块状元素标签(div，h1，p)宽度显示为100%。

第二点，在流动模型下，**内联元素**都会在所处的包含元素内**从左到右**水平分布显示。（内联元素可不像块状元素这么霸道独占一行）

右侧代码编辑器中内联元素标签a、span、em、strong都是内联元素。

#### 浮动模型

块状元素这么霸道都是独占一行，如果现在我们想让**两个块状元素**并排显示，怎么办呢？不要着急，设置元素浮动就可以实现这一愿望。

#####　元素怎样浮动

* 元素的水平方向浮动，意味着元素**只能左右移动**而不能上下移动。
* 一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到**包含框**或**另一个浮动框**的边框为止。
  * 假如某个div元素A是浮动的，如果A元素**上一个元素也是浮动的**，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素**上一个元素是标准流中的元素**，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个(块状)元素的底部对齐。
    * 即浮动元素前如果有浮动块状元素、那就跟在上一个浮动元素后边
    * 它前面如果没有浮动元素、但上一个是标准流块状元素，那从上个元素底部开始浮动
* 浮动元素之后的元素将围绕它。(?)
* 浮动元素之前的元素将不会受到影响
  * 即浮动元素浮动元素前面如果没有浮动元素、但上一个是标准流块状元素，那从上个元素底部开始浮动
  * 后面的标准流块状元素D跟在上一个标准流块状元素后边
  * 浮动的块元素虽然脱离了文档流，但对它后面的行元素从左到右的位置中是要以这个浮动元素的位置开始的。

##### 清除浮动属性

* clear属性
  * MDN: The **`clear`** [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS) property sets whether an element must be moved below (cleared) [floating](https://developer.mozilla.org/en-US/docs/Web/CSS/float) elements that precede it. The `clear` property applies to floating and non-floating elements.
  * 翻译: 设置一个元素是否必须移动到它前面的浮动元素的下边。
* 应用场景: 在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，如何防止这种现象？
  * 方法一：html中在浮动元素后面添加内容为空的元素，并给该元素设置clear属性

  * 方法二：给浮动元素的容器(即父级元素)添加overflow: hidden属性 (通过触发BFC方式，实现清除浮动？不推荐这种方法)
  * 方法三：利用:after给浮动元素的容器**(即父级元素)**添加:after伪元素，并给该伪元素设置block和clear属性

#### 层模型

什么是层布局模型？层布局模型就像是图像软件PhotoShop中非常流行的图层编辑功能一样，每个图层能够精确定位操作，但在网页设计领域，由于网页大小的活动性，层布局没能受到热捧。但是在网页上局部使用层布局还是有其方便之处的。下面我们来学习一下html中的层布局。

如何让html元素在网页中精确定位，就像图像软件PhotoShop中的图层一样可以对每个图层能够精确定位操作。CSS定义了一组定位（positioning）属性来支持层布局模型。

层模型有三种形式：

1、**绝对定位**(position: absolute)

2、**相对定位**(position: relative)

3、**固定定位**(position: fixed)

##### 绝对定位

如果想为元素设置层模型中的绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素**从文档流中拖出来**，然后使用left、right、top、bottom属性**相对于其最接近的一个具有定位属性的父包含块**进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于**浏览器窗口**。

如下面代码可以实现div元素相对于浏览器窗口向右移动100px，向下移动50px。

```
div{
    width:200px;
    height:200px;
    border:2px red solid;
    position:absolute;
    left:100px;
    top:50px;
}
<div id="div1"></div>
```

#####　相对定位

如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在**正常文档流中**的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于**以前的位置移动，**移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。

如下代码实现相对于以前位置向下移动50px，向右移动100px;

```
#div1{
    width:200px;
    height:200px;
    border:2px red solid;
    position:relative;
    left:100px;
    top:50px;
}

<div id="div1"></div>
```

##### 固定定位

fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（**屏幕内的网页窗口**）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与background-attachment:fixed;属性功能相同。

##### z-index

* z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。
* 注释：元素可拥有负的 z-index 属性值。
* 注释：Z-index 仅能在定位元素上奏效（例如 position:absolute;）！

##### position: sticky

* 在SuperMall练习项目中，position: sticky实现：当向下滚动到某地方的时候TabControl固定住不滚动。
* 但很多浏览器不支持这个属性，因为属性比较新。

## Flex弹性盒模型

* 详见阮一峰网站。
* 设置display: flex属性可以把块级元素在一排显示。
* flex需要添加在父元素上，改变子元素的排列顺序。
* 默认为从左往右依次排列,且和父元素左边没有间隙。
* flex:1; 就是代表均匀分配元素。(这个是添加在子元素上的)

## 水平居中技巧

#### 行内元素

```text-align:center```

#### 定宽块状元素

```
margin-left:auto;
margin-right:auto;
```

#### 已知宽高、在盒子内水平垂直居中

```
## 盒子为box, 已知宽高的元素为box1
.box {
    border: 1px solid #00ee00;
    height: 300px;
    position:relative;
}

.box1 {
    width: 200px;
    height: 100px;
    border: 1px solid red;
    position:absolute;
    top:50%;
    left:50%;
    margin:-50px -100px;
}
```

#### 不知宽高、在盒子内水平居中

```
    .box {
        border: 1px solid #00ee00;
        height: 300px;
        position:relative;
        
    }

    .box1 {
        border: 1px solid red;
        position:absolute;
        top:50%;
        left:50%;
        transform:translate(-50%,-50%);
    }
```

* 还有另外一种方式，参考Vue“模式组件”那个示例
  * 给要水平居中的元素(我称之为目标元素)套个父元素，让父元素先在垂直方向上居中
  * 然后目标元素在父元素水平方向上居中。



## 其他样式

#### BFC (Block fomatting context)

* 是什么
* 布局规则及相应的使用场景

#### box-shadow

* ``box-shadow: 0px -1px 1px rgba(100, 100, 100, 0.2)``
  * 水平移动距离
  * 垂直移动距离
  * 模糊度
  * rgb设置颜色，a设置透明度

#### overflow

* ``overflow-y: scroll``可以设置y轴上滚动





